scala提供的常用注解
其实里面很多都是针对java中的概念和概念提供的

跟大家提示一下，再次证明了，你搞scala，真想搞好的话，先学和精通java
scala和java的关系是唇齿相依的
scala依赖java
java并不依赖scala

scala中，常用的一些注解，全部是针对java的一些概念

所以呢，在这里我们没办法给大家详细讲解java的概念，就直接介绍scala中针对java的一些注解

@volatile var name = "leo"			轻量级的java多线程并发安全控制

jvm，java虚拟机中，可以有多个线程
每个线程都有自己的工作区，还有一块儿所有线程共享的工作区
每次一个线程拿到一个公共的变量，都需要从共享区中拷贝一个副本到自己的工作区中使用，和修改
然后修改完以后，再在一个合适的时机，将副本的值，写回到共享区中

这里就会出现一个多线程并发访问安全的问题
多个线程如果同时拷贝了变量副本，都做了不同的修改
然后依次将副本修改的值，写回到共享区中，会依次覆盖掉之前的一些副本值
就会出现变量的值，是不符合预期的
咱们的系统，出现了错误和bug

volatile关键字修饰的变量
它可以保证，一个线程在从共享区获取一个变量的副本时，都会强制刷新一下这个变量的值
保证自己获取到的变量的副本值是最新的
所以这样子做呢，是一种轻量级的多线程并发访问控制办法

但是也不是百分之百保险的，还是有可能会出现错误的风险

@transient var name = "leo"		瞬态字段，不会序列化这个字段

之前讲序列化，默认会将一个对象中所有的字段的值，都序列化到磁盘文件中去
然后反序列化的时候，还可以获取这些字段的值
加了transient的字段，是瞬态的，序列化的时候，不会序列化这个字段
反序列化的时候，这个字段也就没有值了

@SerialVersionUID(value)		标记类的序列化版本号

序列化版本号，这个什么意思
如果我们将一个类的对象序列化到磁盘文件上了
结果过了一段时间以后，这个类在代码中改变了，此时如果你想将磁盘文件中的对象反序列化回来
就会报错，因为你的序列化的对象的结构与代码中的类结构已经不一样了

针对这种问题，就应该有一个序列化版本号
如果你的类改变了，就重新生成一个序列化版本号
反序列化的时候，就会发现序列化类型的版本号和代码中的类的版本号，不一样

@native						标注用c实现的本地方法
@throws(classOf[Exception]) def test() {}	给方法标记要抛出的checked异常
@varargs def test(args: String*) {}		标记方法接收的是变长参数
@BeanProperty				标记生成JavaBean风格的getter和setter方法
@BooleanBeanProperty			标记生成is风格的getter方法，用于boolean类型的field
@deprecated(message = "")		让编译器提示警告
@unchecked						让编译器提示类型转换的警告
